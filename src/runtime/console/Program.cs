using OpenGL;
using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Threading;
using Uno.AppLoader.Dummy;
using Uno.Diagnostics;
using Uno.Platform;
using Uno.Platform.Internal;

namespace Uno.AppLoader
{
    class Program
    {
        [STAThread]
        static void Main()
        {
            GL.Initialize(new DummyGL());
            GraphicsContextBackend.SetInstance(new DummyGC());
            WindowBackend.SetInstance(new DummyWindow());

            UnoGenerated();
            DotNetApplication.Start();

            const double targetTime = 1.0 / 60;

            while (Application.Current != null)
            {
                var startTime = Clock.GetSeconds();

                Bootstrapper.OnUpdate();
                Bootstrapper.OnDraw();

                var renderTime = Clock.GetSeconds() - startTime;
                var msTimeout = (int)((targetTime - renderTime) * 1000.0 + 0.5);

                if (msTimeout > 0)
                    Thread.Sleep(msTimeout);
            }
        }

        // Uno compiler will replace this function
        static void UnoGenerated()
        {
#if LOAD_APP
            LoadUnoApp(typeof(Program).Assembly.Location.Replace(".exe.dll", ".dll"), "MainClass");
        }

        static Application LoadUnoApp(string assemblyPath, string mainClass)
        {
            var assembly = Assembly.LoadFrom(assemblyPath);
            IO.Bundle.Initialize(assembly);
            var type = assembly.GetType(mainClass, true);
            return (Application)Activator.CreateInstance(type);
#endif
        }

        static void UnhandledExceptionTrapper(object sender, UnhandledExceptionEventArgs e)
        {
            Console.Error.WriteLine("The application has crashed because of an unhandled exception:\n\n" + e.ExceptionObject);
            Environment.Exit(1);
        }

        static Program()
        {
            CultureInfo.DefaultThreadCurrentCulture = CultureInfo.InvariantCulture;
            CultureInfo.DefaultThreadCurrentUICulture = CultureInfo.InvariantCulture;
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
            Thread.CurrentThread.CurrentUICulture = CultureInfo.InvariantCulture;
            AppDomain.CurrentDomain.UnhandledException += UnhandledExceptionTrapper;

            AppDomain.CurrentDomain.AssemblyLoad += (sender, ev) => {
                try
                {
                    if (!UsesUnoDllImportResolver(ev.LoadedAssembly))
                        return;

                    // Set DllImportResolver for loading native libraries in assemblies generated by Uno
                    NativeLibrary.SetDllImportResolver(ev.LoadedAssembly, (libraryName, assembly, searchPath) => {
                        if (!libraryName.Contains(".dll") || libraryName.StartsWith("/"))
                            return IntPtr.Zero;

                        var dir = Path.GetDirectoryName(assembly.Location);
                        var lib = Path.Combine(dir,
                            OperatingSystem.IsWindows()
                                ? libraryName
                                : "lib" + libraryName.Replace(".dll",
                                    OperatingSystem.IsMacOS()
                                        ? ".dylib"
                                        : ".so"
                            ));

                        if (File.Exists(lib))
                        {
                            if (OperatingSystem.IsWindows())
                                return LoadLibrary(lib);
                            else if (OperatingSystem.IsMacOS())
                                return Dlfcn.dlopen(lib, 0);
                            else
                                return dlopen(lib, 0);
                        }

                        Console.Error.WriteLine("Native library not found: " + lib);
                        return IntPtr.Zero;
                    });
                }
                catch (Exception e)
                {
                    Console.Error.WriteLine("NativeLibrary.SetDllImportResolver: " + e);
                }
            };
#if LOAD_APP
            AppDomain.CurrentDomain.AssemblyResolve += (sender, e) => {
                var assemblyName = e.Name;

                if (assemblyName.Contains(", Version="))
                    assemblyName = assemblyName.Split(", Version=")[0];

                foreach (var asm in AppDomain.CurrentDomain.GetAssemblies())
                    if (asm.GetName().Name == assemblyName)
                        return asm;

                var dir = Path.GetDirectoryName(typeof(Program).Assembly.Location);
                var path = Path.Combine(dir, assemblyName + ".dll");
                return Assembly.LoadFrom(path);
            };
#endif
        }

        static bool UsesUnoDllImportResolver(Assembly asm)
        {
            foreach (var attr in asm.GetCustomAttributes())
            {
                var metadata = attr as AssemblyMetadataAttribute;

                if (metadata?.Key == "Uno.DllImportResolver")
                    return bool.Parse(metadata.Value);
            }

            return false;
        }

        // Source: https://github.com/xamarin/xamarin-macios/blob/ffdbbbb698ae33981d215bb7b92d7d658b3c1501/src/ObjCRuntime/Dlfcn.cs
        [SupportedOSPlatform("macos")]
        static class Dlfcn
        {
            [Flags]
            public enum Mode : int
            {
                None = 0x0,
                Lazy = 0x1,
                Now = 0x2,
                Local = 0x4,
                Global = 0x8,
                NoLoad = 0x10,
                NoDelete = 0x80,
                First = 0x100,
            }

            [DllImport("/usr/lib/libSystem.dylib", EntryPoint = "dlopen")]
            static extern IntPtr _dlopen(IntPtr path, Mode mode /* this is int32, not nint */);

            [SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>")]
            internal static IntPtr _dlopen(string path, Mode mode /* this is int32, not nint */)
            {
                using var pathPtr = new TransientString(path);
                return _dlopen(pathPtr, mode);
            }

            [SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>")]
            public static IntPtr dlopen(string path, int mode)
            {
                return dlopen(path, mode, showWarning: true);
            }

            [SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>")]
            public static IntPtr dlopen(string path, Mode mode)
            {
                return _dlopen(path, mode);
            }

            static bool warningShown;
            // the linker can eliminate the body of this method (and the above static variable) on release builds
            static void WarnOnce()
            {
                if (!warningShown)
                    Console.Error.WriteLine("You are using dlopen without a full path, retrying by prepending /usr/lib");
                warningShown = true;
            }

            [SuppressMessage("Style", "IDE1006:Naming Styles", Justification = "<Pending>")]
            internal static IntPtr dlopen(string path, int mode, bool showWarning)
            {
                var x = _dlopen(path, (Mode)mode);
                if (x != IntPtr.Zero)
                    return x;

                // In iOS < 9, you could dlopen ("libc") and that would work.
                // In iOS >= 9, this fails with:
                // "no cache image with name (<top>)"
                if (path?.IndexOf('/') == -1)
                {
                    if (showWarning)
                        WarnOnce();
                    return dlopen("/usr/lib/" + path, mode, false);
                }
                return IntPtr.Zero;
            }

            internal struct TransientString : IDisposable
            {
                IntPtr ptr;
                public enum Encoding
                {
                    Auto = 0,
                    BStr,
                    Ansi, // aka LPStr
                    Unicode,
                };

                public TransientString(nint size)
                {
                    ptr = Marshal.AllocHGlobal((IntPtr)size);
                }

                public TransientString(string str, Encoding encoding = Encoding.Auto)
                {
                    ptr = encoding switch
                    {
                        Encoding.Auto => Marshal.StringToHGlobalAuto(str),
                        Encoding.BStr => Marshal.StringToBSTR(str),
                        Encoding.Ansi => Marshal.StringToHGlobalAnsi(str),
                        Encoding.Unicode => Marshal.StringToHGlobalUni(str),
                        _ => throw new ArgumentOutOfRangeException(nameof(encoding)),
                    };
                }

                public void Dispose()
                {
                    if (ptr != IntPtr.Zero)
                    {
                        Marshal.FreeHGlobal(ptr);
                        ptr = IntPtr.Zero;
                    }
                }

                public static implicit operator IntPtr(TransientString str) => str.ptr;
                public static explicit operator string(TransientString str) => Marshal.PtrToStringAuto(str.ptr);

                public static string ToStringAndFree(IntPtr ptr, Encoding encoding = Encoding.Auto)
                {
                    string result = encoding switch
                    {
                        Encoding.Auto => Marshal.PtrToStringAuto(ptr),
                        Encoding.BStr => Marshal.PtrToStringBSTR(ptr),
                        Encoding.Ansi => Marshal.PtrToStringAnsi(ptr),
                        Encoding.Unicode => Marshal.PtrToStringUni(ptr),
                        _ => throw new ArgumentOutOfRangeException(nameof(encoding)),
                    };
                    Marshal.FreeHGlobal(ptr);
                    return result;
                }

                public static IntPtr AllocStringArray(string[] arr, Encoding encoding = Encoding.Auto)
                {
                    if (arr is null)
                        return IntPtr.Zero;
                    var ptrArr = Marshal.AllocHGlobal(arr.Length * IntPtr.Size);
                    var offset = 0;
                    var step = IntPtr.Size;
                    for (int i = 0; i < arr.Length; i++, offset += step)
                    {
                        var str = arr[i] is null ? IntPtr.Zero : new TransientString(arr[i], encoding);
                        Marshal.WriteIntPtr(ptrArr + offset, str);
                    }
                    return ptrArr;
                }

                public static void FreeStringArray(IntPtr ptrArr, int count)
                {
                    if (ptrArr == IntPtr.Zero)
                        return;
                    var offset = 0;
                    var step = IntPtr.Size;
                    for (int i = 0; i < count; i++, offset += step)
                    {
                        var str = Marshal.ReadIntPtr(ptrArr + offset);
                        if (str != IntPtr.Zero)
                            Marshal.FreeHGlobal(Marshal.ReadIntPtr(ptrArr + offset));
                    }
                    Marshal.FreeHGlobal(ptrArr);
                }
            }
        }

        [DllImport("libdl.so")]
        static extern IntPtr dlopen(string filename, int flags);

        [DllImport("kernel32.dll")]
        [SupportedOSPlatform("windows")]
        static extern IntPtr LoadLibrary(string filename);
    }
}
